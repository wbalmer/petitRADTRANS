"""Functions to generate the reference files.
"""
import copy
import os

import matplotlib.pyplot as plt
import numpy as np

from .context import petitRADTRANS
from .utils import radtrans_parameters, reference_filenames, temperature_guillot_2010, temperature_isothermal, version


# Save functions
def __save_2d_transmission_spectrum(filename, wavelengths, relative_velocities, transit_radii,
                                    plot_figure=False, figure_title=None, prt_version=version):
    np.savez_compressed(
        os.path.join(filename),
        wavelengths=wavelengths,
        relative_velocities=relative_velocities,
        transit_radii=transit_radii,
        header=f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'transit_radius units: R_jup',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.pcolormesh(wavelengths, relative_velocities, transit_radii)
        plt.colorbar(label=r'Transit radius (R$_{\rm{Jup}}$)')
        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Orbital phase')
        plt.title(figure_title)


def __save_co_added_cross_correlation(filename,
                                      rest_velocities, orbital_radial_velocity_semi_amplitudes, co_added_cross_correlations,
                                      co_added_cross_correlations_max, max_kp, max_v_rest, n_around_peak,
                                      plot_figure=False, figure_title=None, prt_version=version):
    np.savez_compressed(
        os.path.join(filename),
        rest_velocities=rest_velocities,
        orbital_radial_velocity_semi_amplitudes=orbital_radial_velocity_semi_amplitudes,
        co_added_cross_correlations=co_added_cross_correlations,
        co_added_cross_correlations_max=co_added_cross_correlations_max,
        max_kp=max_kp,
        max_v_rest=max_v_rest,
        n_around_peak=n_around_peak,
        header=f'File generated by tests.utils function\n'
               f'velocity units: cm.s-1',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.pcolormesh(rest_velocities * 1e-5, orbital_radial_velocity_semi_amplitudes * 1e-5, co_added_cross_correlations)
        plt.colorbar(label=r'Co-added CCF')
        plt.xlabel(r'$V_\mathrm{rest}$ (km$\cdot$s$^{-1}$)')
        plt.ylabel(r'$K_p$ (km$\cdot$s$^{-1}$)')
        plt.title(figure_title)


def __save_contribution_function(filename, frequencies, emission_contribution, transmission_contribution,
                                 mode='emission', plot_figure=False, figure_title=None, prt_version=version):
    wavelength = np.asarray(petitRADTRANS.physical_constants.c / frequencies * 1e4)

    if mode == 'emission':
        contribution = np.asarray(emission_contribution)
    elif mode == 'transmission':
        contribution = np.asarray(transmission_contribution)
    else:
        raise ValueError(f"unknown contribution mode '{mode}', available modes are 'emission' or 'transmission'")

    np.savez_compressed(
        os.path.join(filename),
        wavelength=wavelength,
        contribution=contribution,
        header=f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'spectral radiosity units: erg.cm-2.s-1.Hz-1',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        x, y = np.meshgrid(wavelength, np.linspace(np.shape(contribution))[1])
        plt.contourf(x, y, contribution, 30, cmap='bone_r')

        plt.yscale('log')
        plt.xscale('log')
        plt.ylim([1e2, 1e-6])
        plt.xlim([np.min(wavelength), np.max(wavelength)])

        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Pressure (bar)')
        plt.title(figure_title)


def __save_emission_spectrum(filename, frequencies, flux, plot_figure=False, figure_title=None, prt_version=version):
    wavelength = np.asarray(petitRADTRANS.physical_constants.c / frequencies * 1e4)

    np.savez_compressed(
        os.path.join(filename),
        wavelength=wavelength,
        spectral_radiosity=np.asarray(flux),
        header=f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'spectral radiosity units: erg.cm-2.s-1.Hz-1',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.semilogx(wavelength, flux)
        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Spectral radiosity (erg$\cdot$s$^{-1}\cdot$cm$^{-2}\cdot$Hz$^{-1}$)')
        plt.title(figure_title)


def __save_mass_fractions(filename, mass_fractions, mean_molar_masses, nabla_adiabatic,
                          plot_figure=False, y_axis=None, y_label='', y_lim=None,
                          figure_title=None, prt_version=version):
    np.savez_compressed(
        file=os.path.join(filename),
        header=f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'spectral radiosity units: erg.cm-2.s-1.Hz-1',
        prt_version=f'{prt_version}',
        mean_molar_masses=mean_molar_masses,
        nabla_adiabatic=nabla_adiabatic,
        **mass_fractions  # pass mass fractions as keyword arguments to avoid the need of pickle
    )

    if plot_figure:
        if y_axis is None:
            axis_length = np.size(mass_fractions(list(mass_fractions.keys())[0]))
            y_axis = np.linspace(0, axis_length, axis_length)

        # Mass fractions figure
        plt.figure()

        for species in mass_fractions.keys():
            if species not in ['MMW', 'nabla_ad']:  # kept for backward compatibility
                plt.loglog(mass_fractions[species], y_axis, label=species)

        plt.ylim(y_lim)
        plt.xlim([1e-10, 1])
        plt.xlabel(r'Mass fraction')
        plt.ylabel(y_label)
        plt.title('Mass fractions' + figure_title)

        # Nabla figure
        plt.figure()
        plt.loglog(nabla_adiabatic, y_axis)

        plt.ylim(y_lim)
        plt.xlabel(r'Moist adiabatic temperature gradient $\nabla_{\rm ad}$')
        plt.ylabel(y_label)
        plt.title(r'$\nabla_{\rm ad}$' + figure_title)

        # Mean molar mass figure
        plt.figure()
        plt.loglog(mean_molar_masses, y_axis)

        plt.ylim(y_lim)
        plt.xlabel(r'Mean molar mass')
        plt.ylabel(y_label)
        plt.title('Mean molar mass' + figure_title)


def __save_simple_spectrum(filename, wavelengths, spectrum, rebin_wavelengths, rebin_spectrum, cross_correlation,
                           plot_figure=False, figure_title=None, prt_version=version):
    np.savez_compressed(
        os.path.join(filename),
        wavelengths=wavelengths,
        spectrum=spectrum,
        rebin_wavelengths=rebin_wavelengths,
        rebin_spectrum=rebin_spectrum,
        cross_correlation=cross_correlation,
        header=f'File generated by tests.utils function\n'
               f'arbitrary units',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.plot(wavelengths, spectrum)
        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Spectrum (R$_{\rm{Jup}}$)')
        plt.title(figure_title)


def __save_singular_values(filename, prt_version=version, **kwargs):
    np.savez_compressed(
        os.path.join(filename),
        **kwargs,
        header=f'File generated by tests.utils function\n'
               f'arbitrary units',
        prt_version=f'{prt_version}'
    )


def __save_temperature_profile(filename, temperature, plot_figure=False, figure_title=None, prt_version=version):
    np.savez_compressed(
        os.path.join(filename),
        temperature=np.asarray(temperature),
        pressure=np.asarray(radtrans_parameters['pressures']),
        header=f'File generated by tests.utils function\n'
               f'temperature units: K\n'
               f'pressure units: bar',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.semilogy(temperature, radtrans_parameters['pressures'])
        plt.ylim([1e2, 1e-6])
        plt.xlabel('Temperature (K)')
        plt.ylabel('Pressure (bar)')
        plt.title(figure_title)


def __save_transmission_spectrum(filename, frequencies, transit_radii, plot_figure=False, figure_title=None,
                                 prt_version=version):
    wavelength = np.asarray(petitRADTRANS.physical_constants.c / frequencies * 1e4)
    transit_radius = np.asarray(transit_radii / petitRADTRANS.physical_constants.r_jup_mean)

    np.savez_compressed(
        os.path.join(filename),
        wavelength=wavelength,
        transit_radius=transit_radius,
        header=f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'transit_radius units: R_jup',
        prt_version=f'{prt_version}'
    )

    if plot_figure:
        plt.figure()
        plt.semilogx(wavelength, transit_radius)
        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Transit radius (R$_{\rm{Jup}}$)')
        plt.title(figure_title)


def npz2dat(file, new_resolving_power=60.0, relative_error=0.05, mode='transmission'):
    """Converts a .npz spectrum file into a .dat file suitable for the petitRADTRANS.retrieval Data class.

    The .dat file is outputted in the same directory as the .npz file.

    Args:
        file:
            The .npz file to convert.
        new_resolving_power:
            The resolution power of the .dat file. It should be lower than the one in the original file.
        relative_error:
            Mock observation uncertainty to add.
        mode:
            How to read the .npz file ('emission'|'transmission')
    """
    from scripts.mock_observation import convolve_rebin

    npz_data = np.load(file)

    wavelength = npz_data['wavelength']

    if mode == 'emission':
        flux = petitRADTRANS.physics.flux_hz2flux_cm(
            npz_data['spectral_radiosity'],
            petitRADTRANS.physical_constants.c * 1e4 / wavelength  # um to Hz
        )
        flux *= 1e-7  # erg.s-1.cm-2/cm to W.m-2/um

        flux_str = 'spectral_radiosity units: W.m-2/um\n'
    elif mode == 'transmission':
        flux = (
                       npz_data['transit_radius'] * petitRADTRANS.physical_constants.r_jup_mean
                       / (radtrans_parameters['stellar_parameters']['radius'] * petitRADTRANS.physical_constants.r_sun)
               ) ** 2
        flux_str = 'transit_radius units: (R_p/R_star)^2\n'
    else:
        raise ValueError(f"mode must be 'emission' or 'transmission', but was '{mode}'")

    dump, wavelength, flux = convolve_rebin(
        input_wavelengths=wavelength,
        input_flux=flux,
        instrument_resolving_power=new_resolving_power,
        pixel_sampling=1,
        instrument_wavelength_range=(wavelength[1], wavelength[-1])
    )

    error = relative_error * np.max(flux)

    flux += np.random.default_rng().normal(
        loc=0.,
        scale=error,
        size=np.size(flux)
    )

    error *= np.ones_like(wavelength)

    np.savetxt(
        fname=file.rsplit('.', 1)[0] + '.dat',
        X=np.transpose((wavelength, flux, error)),
        header='wavelength flux error\n'
               f'File generated by tests.utils function\n'
               f'wavelength units: um\n'
               f'error and {flux_str}'
               f'resolution power {new_resolving_power}\n'
               f'relative error {relative_error}\n'
               f'original file: {file}'
    )


# Data files generation functions
def create_radtrans_2d_line_by_line_transmission_spectrum_ref(plot_figure=False):
    from .test_radtrans_line_by_line import spectral_model_lbl, radtrans_spectral_model_lbl

    spectral_model = copy.deepcopy(spectral_model_lbl)

    spectral_model.model_parameters['temperature_profile_mode'] = 'isothermal'
    spectral_model.model_parameters['temperature'] = temperature_isothermal

    wavelengths, mock_transmission_data = spectral_model.calculate_spectrum(
        radtrans=radtrans_spectral_model_lbl,
        mode='transmission',
        parameters=None,
        update_parameters=True,
        telluric_transmittances=None,
        instrumental_deformations=None,
        noise_matrix=None,
        scale=True,
        shift=True,
        convolve=True,
        rebin=True,
        reduce=False
    )

    __save_2d_transmission_spectrum(
        reference_filenames['line_by_line_transmission_2d'],
        wavelengths=wavelengths,
        relative_velocities=spectral_model_lbl.model_parameters['relative_velocities'],
        transit_radii=mock_transmission_data,
        plot_figure=plot_figure,
        figure_title='2D line-by-line transmission spectrum, using SpectralModel'
    )

    # Get models
    wavelengths_model, model = spectral_model.calculate_spectrum(
        radtrans=radtrans_spectral_model_lbl,
        mode='transmission',
        parameters=None,
        update_parameters=True,
        telluric_transmittances=None,
        instrumental_deformations=None,
        noise_matrix=None,
        scale=True,
        shift=True,
        convolve=True,
        rebin=False,
        reduce=False
    )

    line_spread_function_fwhm = petitRADTRANS.physical_constants.c /\
        radtrans_parameters['mock_observation_parameters']['high_resolution_resolving_power']

    co_added_cross_correlations_snr, co_added_cross_correlations, \
        v_rest, kps, ccf_sum, ccfs, velocities_ccf, ccf_models, ccf_model_wavelengths \
        = petitRADTRANS.ccf.ccf.ccf_analysis(
            wavelengths_data=wavelengths,
            data=mock_transmission_data,
            wavelengths_model=wavelengths_model,
            model=model,
            velocities_ccf=None,
            model_velocities=spectral_model.model_parameters['relative_velocities'],
            normalize_ccf=radtrans_parameters['ccf_analysis_parameters']['normalize_ccf'],
            calculate_ccf_snr=radtrans_parameters['ccf_analysis_parameters']['calculate_ccf_snr'],
            ccf_sum_axes=radtrans_parameters['ccf_analysis_parameters']['ccf_sum_axes'],
            radial_velocity_semi_amplitude=spectral_model.model_parameters['radial_velocity_semi_amplitude'],
            system_observer_radial_velocities=spectral_model.model_parameters['system_observer_radial_velocities'],
            orbital_phases=spectral_model.model_parameters['orbital_phases'],
            orbital_inclination=spectral_model.model_parameters['planet_orbital_inclination'],
            line_spread_function_fwhm=line_spread_function_fwhm,
            pixels_per_resolution_element=radtrans_parameters['ccf_analysis_parameters'][
                'pixels_per_resolution_element'],
            co_added_ccf_peak_width=line_spread_function_fwhm * radtrans_parameters[
                'ccf_analysis_parameters']['peak_lsf_factor'],
            velocity_interval_extension_factor=radtrans_parameters['ccf_analysis_parameters'][
                'velocity_interval_extension_factor'],
            kp_factor=radtrans_parameters['ccf_analysis_parameters']['kp_factor'],
            n_kp=None,
            n_vr=None,
            radial_velocity_function=None
        )

    co_added_cross_correlations_max, max_kp, max_v_rest, n_around_peak \
        = petitRADTRANS.ccf.ccf.get_co_added_ccf_peak_properties(
            co_added_cross_correlation=co_added_cross_correlations,
            kp_space=kps,
            vr_space=v_rest,
            peak_cutoff=radtrans_parameters['ccf_analysis_parameters']['peak_cutoff']
        )

    __save_co_added_cross_correlation(
        filename=reference_filenames['co_added_cross_correlation'],
        rest_velocities=v_rest,
        orbital_radial_velocity_semi_amplitudes=kps,
        co_added_cross_correlations=co_added_cross_correlations,
        co_added_cross_correlations_max=co_added_cross_correlations_max,
        max_kp=max_kp,
        max_v_rest=max_v_rest,
        n_around_peak=n_around_peak,
        plot_figure=plot_figure,
        figure_title='Co-added cross correlation of the 2D line-by-line transmission spectrum with itself'
    )


def create_guillot_2010_temperature_profile_ref(plot_figure=False):
    temperature_guillot = petitRADTRANS.physics.temperature_profile_function_guillot_global(
        pressures=radtrans_parameters['pressures'],
        infrared_mean_opacity=radtrans_parameters['temperature_guillot_2010_parameters']['infrared_mean_opacity'],
        gamma=radtrans_parameters['temperature_guillot_2010_parameters']['gamma'],
        gravities=radtrans_parameters['planetary_parameters']['surface_gravity'],
        intrinsic_temperature=radtrans_parameters['temperature_guillot_2010_parameters']['intrinsic_temperature'],
        equilibrium_temperature=radtrans_parameters['temperature_guillot_2010_parameters']['equilibrium_temperature']
    )

    __save_temperature_profile(
        reference_filenames['guillot_2010'], temperature_guillot, plot_figure, 'Guillot 2010 temperature profile'
    )


def create_mock_observation_transmission_spectrum(plot_figure=False):
    npz2dat(
        file=reference_filenames['correlated_k_transmission_cloud_calculated_radius_scattering'],
        new_resolving_power=radtrans_parameters['mock_observation_parameters']['resolving_power'],
        relative_error=radtrans_parameters['mock_observation_parameters']['relative_error'],
        mode='transmission'
    )

    if plot_figure:
        data = np.loadtxt(reference_filenames['mock_observation_transmission'])
        wavelength = data[:, 0]
        transit_radius = data[:, 1]
        error = data[:, 2]

        plt.figure()
        plt.errorbar(wavelength, transit_radius, yerr=error, ls='', marker='+', capsize=2)
        plt.xlabel(r'Wavelength ($\mu$m)')
        plt.ylabel(r'Transit radius (R$_{\rm{Jup}}$)')
        plt.title('Mock observed spectrum')


def create_radtrans_correlated_k_emission_spectrum_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    frequencies, flux, _ = atmosphere_ck.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['correlated_k_emission'], frequencies, flux, plot_figure, 'Correlated-k emission spectrum'
    )


def create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, flux, additional_outputs = atmosphere_ck.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
        cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['f_sed'],
        cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS'
        ]['sigma_log_normal'],
        return_contribution=True,
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['correlated_k_emission_cloud_calculated_radius'], frequencies, flux, plot_figure,
        'Correlated-k emission spectrum, with non-gray cloud using Hansen radius',
        prt_version=version
    )

    __save_contribution_function(
        filename=reference_filenames['correlated_k_emission_contribution_cloud_calculated_radius'],
        frequencies=frequencies,
        emission_contribution=additional_outputs['emission_contribution'],
        transmission_contribution=None,
        mode='emission',
        plot_figure=plot_figure,
        figure_title='Correlated-k emission contribution function, '
                     'with non-gray cloud using calculated radius',
        prt_version=version
    )


def create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_stellar_scattering_ref(plot_figure=False):
    from .test_radtrans_correlated_k_scattering import atmosphere_ck_scattering

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    geometries = [
        'planetary_ave',
        'dayside_ave',
        'non-isotropic'
    ]

    for geometry in geometries:
        frequencies, flux, _ = atmosphere_ck_scattering.calculate_flux(
            temperatures=temperature_guillot_2010,
            mass_fractions=mass_fractions,
            reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
            mean_molar_masses=radtrans_parameters['mean_molar_mass'],
            eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
            cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species'][
                'Mg2SiO4(s)_crystalline__DHS']['f_sed'],
            cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
                'Mg2SiO4(s)_crystalline__DHS']['sigma_log_normal'],
            emission_geometry=geometry,
            star_effective_temperature=radtrans_parameters['stellar_parameters']['effective_temperature'],
            star_radius=radtrans_parameters['stellar_parameters']['radius'] * petitRADTRANS.physical_constants.r_sun,
            orbit_semi_major_axis=radtrans_parameters['planetary_parameters']['orbit_semi_major_axis'],
            star_irradiation_angle=radtrans_parameters['stellar_parameters']['incidence_angle'],
            frequencies_to_wavelengths=False
        )

        __save_emission_spectrum(
            reference_filenames[f'correlated_k_emission_cloud_calculated_radius_scattering_{geometry}'],
            frequencies, flux, plot_figure,
            f'Correlated-k transmission spectrum, '
            f'with non-gray cloud using calculated radius and scattering ({geometry})',
            prt_version=version
        )


def create_radtrans_correlated_k_emission_spectrum_cloud_hansen_radius_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, flux, _ = atmosphere_ck.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
        cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['f_sed'],
        cloud_hansen_b=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS']['b_hansen'],
        cloud_particles_radius_distribution='hansen',
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['correlated_k_emission_cloud_hansen_radius'], frequencies, flux, plot_figure,
        'Correlated-k emission spectrum, with non-gray cloud using Hansen radius',
        prt_version=petitRADTRANS.__version__
    )


def create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_scattering_ref(plot_figure=False):
    from .test_radtrans_correlated_k_scattering import atmosphere_ck_scattering

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, flux, _ = atmosphere_ck_scattering.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
        cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['f_sed'],
        cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS']['sigma_log_normal'],
        add_cloud_scattering_as_absorption=True,
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['correlated_k_emission_cloud_calculated_radius_scattering'],
        frequencies, flux,
        plot_figure,
        'Correlated-k emission spectrum, with non-gray cloud using calculated radius and scattering',
        prt_version=version
    )


def create_radtrans_correlated_k_emission_spectrum_surface_scattering_ref(plot_figure=False):
    from .test_radtrans_correlated_k_surface_scattering import atmosphere_ck_surface_scattering

    # Copy atmosphere so that change in reflectance is not carried outside the function
    atmosphere = copy.deepcopy(atmosphere_ck_surface_scattering)

    atmosphere.reflectance = radtrans_parameters['planetary_parameters']['surface_reflectance'] \
        * np.ones_like(atmosphere.frequencies)

    frequencies, flux, _ = atmosphere.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        emission_geometry='non-isotropic',
        star_effective_temperature=radtrans_parameters['stellar_parameters']['effective_temperature'],
        star_radius=radtrans_parameters['stellar_parameters']['radius'] * petitRADTRANS.physical_constants.r_sun,
        orbit_semi_major_axis=radtrans_parameters['planetary_parameters']['orbit_semi_major_axis'],
        star_irradiation_angle=radtrans_parameters['stellar_parameters']['incidence_angle'],
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['correlated_k_emission_surface_scattering'],
        frequencies, flux, plot_figure, 'Correlated-k emission spectrum with surface scattering'
    )


def create_radtrans_correlated_k_transmission_spectrum_cloud_calculated_radius_scattering_ref(plot_figure=False):
    from .test_radtrans_correlated_k_scattering import atmosphere_ck_scattering

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, transit_radii, _ = atmosphere_ck_scattering.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
        cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['f_sed'],
        cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS']['sigma_log_normal'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_cloud_calculated_radius_scattering'],
        frequencies, transit_radii,
        plot_figure,
        'Correlated-k transmission spectrum, with non-gray cloud using calculated radius and scattering',
        prt_version=version
    )


def create_radtrans_correlated_k_transmission_spectrum_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    frequencies, transit_radii, _ = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission'], frequencies, transit_radii, plot_figure,
        'Correlated-k transmission spectrum'
    )


def create_radtrans_correlated_k_transmission_spectrum_cloud_power_law_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    frequencies, transit_radii, _ = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        power_law_opacity_350nm=radtrans_parameters['cloud_parameters']['kappa_zero'],
        power_law_opacity_coefficient=radtrans_parameters['cloud_parameters']['gamma_scattering'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_cloud_power_law'],
        frequencies, transit_radii, plot_figure, 'Correlated-k transmission spectrum, with power law cloud'
    )


def create_radtrans_correlated_k_transmission_spectrum_gray_cloud_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    frequencies, transit_radii, _ = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        opaque_cloud_top_pressure=radtrans_parameters['cloud_parameters']['cloud_pressure'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_gray_cloud'],
        frequencies, transit_radii, plot_figure, 'Correlated-k transmission spectrum, with gray cloud'
    )


def create_radtrans_correlated_k_transmission_spectrum_rayleigh_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    frequencies, transit_radii, _ = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        haze_factor=radtrans_parameters['cloud_parameters']['haze_factor'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_rayleigh'],
        frequencies, transit_radii, plot_figure, 'Correlated-k transmission spectrum, with hazes'
    )


def create_radtrans_correlated_k_transmission_spectrum_cloud_fixed_radius_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, transit_radii, _ = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        cloud_particles_mean_radii={'Mg2SiO4(s)_crystalline__DHS': radtrans_parameters['cloud_parameters'][
            'cloud_species']['Mg2SiO4(s)_crystalline__DHS']['radius']},
        cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS'
        ]['sigma_log_normal'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_cloud_fixed_radius'], frequencies, transit_radii, plot_figure,
        'Correlated-k transmission spectrum, with non-gray cloud using fixed radius'
    )


def create_radtrans_correlated_k_transmission_spectrum_cloud_calculated_radius_ref(plot_figure=False):
    from .test_radtrans_correlated_k import atmosphere_ck

    mass_fractions = copy.deepcopy(radtrans_parameters['mass_fractions'])
    mass_fractions['Mg2SiO4(s)_crystalline__DHS'] = \
        radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['mass_fraction']

    frequencies, transit_radii, additional_outputs = atmosphere_ck.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=mass_fractions,
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        eddy_diffusion_coefficients=radtrans_parameters['planetary_parameters']['eddy_diffusion_coefficients'],
        cloud_f_sed=radtrans_parameters['cloud_parameters']['cloud_species']['Mg2SiO4(s)_crystalline__DHS']['f_sed'],
        cloud_particle_radius_distribution_std=radtrans_parameters['cloud_parameters']['cloud_species'][
            'Mg2SiO4(s)_crystalline__DHS'
        ]['sigma_log_normal'],
        return_contribution=True,
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['correlated_k_transmission_cloud_calculated_radius'], frequencies, transit_radii,
        plot_figure,
        'Correlated-k transmission spectrum, with non-gray cloud using calculated radius'
    )

    __save_contribution_function(
        filename=reference_filenames['correlated_k_transmission_contribution_cloud_calculated_radius'],
        frequencies=frequencies,
        emission_contribution=None,
        transmission_contribution=additional_outputs['transmission_contribution'],
        mode='transmission',
        plot_figure=plot_figure,
        figure_title='Correlated-k transmission contribution function, '
                     'with non-gray cloud using calculated radius',
        prt_version=version
    )


def create_radtrans_line_by_line_downsampled_emission_spectrum_ref(plot_figure=False):
    from .test_radtrans_line_by_line_sampling import atmosphere_lbl_downsampled

    frequencies, flux, _ = atmosphere_lbl_downsampled.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['line_by_line_downsampled_emission'],
        frequencies, flux, plot_figure, 'Line-by-line downsampled emission spectrum'
    )


def create_radtrans_line_by_line_downsampled_transmission_spectrum_ref(plot_figure=False):
    from .test_radtrans_line_by_line_sampling import atmosphere_lbl_downsampled

    frequencies, transit_radii, _ = atmosphere_lbl_downsampled.calculate_transit_radii(
        temperatures=temperature_isothermal,
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['line_by_line_downsampled_transmission'],
        frequencies, transit_radii, plot_figure, 'Line-by-line downsampled transmission spectrum'
    )


def create_radtrans_line_by_line_emission_spectrum_ref(plot_figure=False):
    from .test_radtrans_line_by_line import atmosphere_lbl

    frequencies, flux, _ = atmosphere_lbl.calculate_flux(
        temperatures=temperature_guillot_2010,
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        frequencies_to_wavelengths=False
    )

    __save_emission_spectrum(
        reference_filenames['line_by_line_emission'],
        frequencies, flux, plot_figure, 'Line-by-line emission spectrum'
    )


def create_radtrans_line_by_line_transmission_spectrum_ref(plot_figure=False):
    from .test_radtrans_line_by_line import atmosphere_lbl

    frequencies, transit_radii, _ = atmosphere_lbl.calculate_transit_radii(
        temperatures=radtrans_parameters['temperature_isothermal'] * np.ones_like(radtrans_parameters['pressures']),
        mass_fractions=radtrans_parameters['mass_fractions'],
        reference_gravity=radtrans_parameters['planetary_parameters']['surface_gravity'],
        mean_molar_masses=radtrans_parameters['mean_molar_mass'],
        planet_radius=radtrans_parameters['planetary_parameters']['radius']
        * petitRADTRANS.physical_constants.r_jup_mean,
        reference_pressure=radtrans_parameters['planetary_parameters']['reference_pressure'],
        frequencies_to_wavelengths=False
    )

    __save_transmission_spectrum(
        reference_filenames['line_by_line_transmission'],
        frequencies, transit_radii, plot_figure, 'Line-by-line transmission spectrum'
    )


def create_radtrans_mass_fractions_atmosphere_ref(plot_figure=False):
    c_o_ratios = radtrans_parameters['chemical_parameters']['c_o_ratios'][1] \
        * np.ones_like(radtrans_parameters['pressures'])
    metallicities = radtrans_parameters['chemical_parameters']['metallicities'][1] \
        * np.ones_like(radtrans_parameters['pressures'])

    mass_fractions, mean_molar_masses, nabla_adiabatic = (
        petitRADTRANS.chemistry.pre_calculated_chemistry.pre_calculated_equilibrium_chemistry_table.
        interpolate_mass_fractions(
            co_ratios=c_o_ratios,
            log10_metallicities=metallicities,
            temperatures=temperature_guillot_2010,
            pressures=radtrans_parameters['pressures'],
            full=True
        )
    )

    __save_mass_fractions(
        filename=reference_filenames['mass_fractions_atmosphere'],
        mass_fractions=mass_fractions,
        mean_molar_masses=mean_molar_masses,
        nabla_adiabatic=nabla_adiabatic,
        plot_figure=plot_figure,
        y_axis=radtrans_parameters['pressures'],
        y_label='Pressure (bar)',
        y_lim=[np.max(radtrans_parameters['pressures']), np.min(radtrans_parameters['pressures'])],
        figure_title=' for a Guillot 2010 temperature profile',
        prt_version=version
    )


def create_radtrans_mass_fractions_atmosphere_quench_ref(plot_figure=False):
    c_o_ratios = radtrans_parameters['chemical_parameters']['c_o_ratios'][1] \
        * np.ones_like(radtrans_parameters['pressures'])
    metallicities = radtrans_parameters['chemical_parameters']['metallicities'][1] \
        * np.ones_like(radtrans_parameters['pressures'])

    mass_fractions, mean_molar_masses, nabla_adiabatic = (
        petitRADTRANS.chemistry.pre_calculated_chemistry.pre_calculated_equilibrium_chemistry_table.
        interpolate_mass_fractions(
            co_ratios=c_o_ratios,
            log10_metallicities=metallicities,
            temperatures=temperature_guillot_2010,
            pressures=radtrans_parameters['pressures'],
            carbon_pressure_quench=radtrans_parameters['chemical_parameters']['pressure_quench_carbon'],
            full=True
        )
    )

    __save_mass_fractions(
        filename=reference_filenames['mass_fractions_atmosphere_quench'],
        mass_fractions=mass_fractions,
        mean_molar_masses=mean_molar_masses,
        nabla_adiabatic=nabla_adiabatic,
        plot_figure=plot_figure,
        y_axis=radtrans_parameters['pressures'],
        y_label='Pressure (bar)',
        y_lim=[np.max(radtrans_parameters['pressures']), np.min(radtrans_parameters['pressures'])],
        figure_title=' for a Guillot 2010 temperature profile',
        prt_version=version
    )


def create_radtrans_mass_fractions_c_o_ratios_ref(plot_figure=False):
    c_o_ratios = np.asarray(radtrans_parameters['chemical_parameters']['c_o_ratios'])
    metallicities = radtrans_parameters['chemical_parameters']['metallicities'][1] * np.ones_like(c_o_ratios)
    pressures = radtrans_parameters['chemical_parameters']['pressure'] * np.ones_like(c_o_ratios)
    temperatures = radtrans_parameters['chemical_parameters']['temperature'] * np.ones_like(c_o_ratios)

    mass_fractions, mean_molar_masses, nabla_adiabatic = (
        petitRADTRANS.chemistry.pre_calculated_chemistry.pre_calculated_equilibrium_chemistry_table.
        interpolate_mass_fractions(
            co_ratios=c_o_ratios,
            log10_metallicities=metallicities,
            temperatures=temperatures,
            pressures=pressures,
            full=True
        )
    )

    __save_mass_fractions(
        filename=reference_filenames['mass_fractions_c_o_ratios'],
        mass_fractions=mass_fractions,
        mean_molar_masses=mean_molar_masses,
        nabla_adiabatic=nabla_adiabatic,
        plot_figure=plot_figure,
        y_axis=c_o_ratios,
        y_label='C/O',
        y_lim=[np.min(c_o_ratios), np.max(c_o_ratios)],
        figure_title=' for different C/O',
        prt_version=version
    )


def create_radtrans_mass_fractions_metallicities_ref(plot_figure=False):
    metallicities = np.asarray(radtrans_parameters['chemical_parameters']['metallicities'])
    c_o_ratios = radtrans_parameters['chemical_parameters']['c_o_ratios'][1] * np.ones_like(metallicities)
    pressures = radtrans_parameters['chemical_parameters']['pressure'] * np.ones_like(metallicities)
    temperatures = radtrans_parameters['chemical_parameters']['temperature'] * np.ones_like(metallicities)

    mass_fractions, mean_molar_masses, nabla_adiabatic = (
        petitRADTRANS.chemistry.pre_calculated_chemistry.pre_calculated_equilibrium_chemistry_table.
        interpolate_mass_fractions(
            co_ratios=c_o_ratios,
            log10_metallicities=metallicities,
            temperatures=temperatures,
            pressures=pressures,
            full=True
        )
    )

    __save_mass_fractions(
        filename=reference_filenames['mass_fractions_metallicities'],
        mass_fractions=mass_fractions,
        mean_molar_masses=mean_molar_masses,
        nabla_adiabatic=nabla_adiabatic,
        plot_figure=plot_figure,
        y_axis=10 ** metallicities,
        y_label='[Fe/H]',
        y_lim=[10 ** np.min(metallicities), 10 ** np.max(metallicities)],
        figure_title=' for different metallicities',
        prt_version=version
    )


def create_simple_spectrum(plot_figure=False):
    wavelengths = np.linspace(0.85, 2.15, 20)
    spectrum = np.sin(3 * wavelengths) + np.sin(10 * wavelengths)
    rebin_wavelengths = np.linspace(1, 2, 5)

    rebin_spectrum = petitRADTRANS.fortran_rebin.fortran_rebin.rebin_spectrum(
            wavelengths, spectrum, rebin_wavelengths
    )

    cross_correlation = petitRADTRANS.ccf.ccf_core.cross_correlate_matrices(
        matrix_1=spectrum,
        matrix_2=spectrum
    )

    __save_simple_spectrum(
        filename=reference_filenames['simple_spectrum'],
        wavelengths=wavelengths,
        spectrum=spectrum,
        rebin_wavelengths=rebin_wavelengths,
        rebin_spectrum=rebin_spectrum,
        cross_correlation=cross_correlation,
        plot_figure=plot_figure
    )


def create_singular_values():
    planet = petitRADTRANS.containers.planet.Planet.get(radtrans_parameters['planetary_parameters']['name'])

    planet.star_effective_temperature = radtrans_parameters['stellar_parameters']['effective_temperature']
    planet.star_radius = radtrans_parameters['stellar_parameters']['radius'] * petitRADTRANS.physical_constants.r_sun
    planet.orbit_semi_major_axis = radtrans_parameters['planetary_parameters']['orbit_semi_major_axis']
    planet.bond_albedo = radtrans_parameters['planetary_parameters']['surface_reflectance']

    planet_equilibrium_temperature, \
        planet_equilibrium_temperature_error_upper, \
        planet_equilibrium_temperature_error_lower = planet.calculate_planetary_equilibrium_temperature()

    __save_singular_values(
        filename=reference_filenames['singular_values']
    )


def create_all_comparison_files(plot_figure=False):
    create_guillot_2010_temperature_profile_ref(plot_figure)

    create_radtrans_correlated_k_emission_spectrum_ref(plot_figure)
    create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_ref(plot_figure)
    create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_scattering_ref(plot_figure)
    create_radtrans_correlated_k_emission_spectrum_cloud_calculated_radius_stellar_scattering_ref(plot_figure)
    create_radtrans_correlated_k_emission_spectrum_cloud_hansen_radius_ref(plot_figure)
    create_radtrans_correlated_k_emission_spectrum_surface_scattering_ref(plot_figure)

    create_radtrans_correlated_k_transmission_spectrum_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_cloud_power_law_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_rayleigh_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_gray_cloud_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_cloud_fixed_radius_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_cloud_calculated_radius_ref(plot_figure)
    create_radtrans_correlated_k_transmission_spectrum_cloud_calculated_radius_scattering_ref(plot_figure)

    create_radtrans_line_by_line_downsampled_emission_spectrum_ref(plot_figure)
    create_radtrans_line_by_line_downsampled_transmission_spectrum_ref(plot_figure)
    create_radtrans_line_by_line_emission_spectrum_ref(plot_figure)
    create_radtrans_line_by_line_transmission_spectrum_ref(plot_figure)
    create_radtrans_2d_line_by_line_transmission_spectrum_ref(plot_figure)

    create_radtrans_mass_fractions_atmosphere_ref(plot_figure)
    create_radtrans_mass_fractions_atmosphere_quench_ref(plot_figure)
    create_radtrans_mass_fractions_c_o_ratios_ref(plot_figure)
    create_radtrans_mass_fractions_metallicities_ref(plot_figure)

    create_simple_spectrum(plot_figure)
    create_singular_values()

    create_mock_observation_transmission_spectrum(plot_figure)
