"""Utility functions for tests.

Regenerate the comparison files only when changing the precision of the models.
"""
import copy
import json
import os

import numpy as np

from .context import petitRADTRANS

version = petitRADTRANS.__version__  # version used to generate last tests

tests_data_directory = os.path.join(os.path.dirname(__file__), 'data')
tests_references_directory = os.path.join(os.path.dirname(__file__), 'references')
tests_error_directory = os.path.join(os.path.dirname(__file__), 'errors')
tests_results_directory = os.path.join(os.path.dirname(__file__), 'results')
reference_filenames = {
    'config_test_radtrans':
        'config_test_radtrans',
    'guillot_2010':
        'radtrans_guillot_2010_temperature_profile_ref',
    'correlated_k_transmission_cloud_calculated_radius_scattering':
        'radtrans_correlated_k_transmission_cloud_calculated_radius_scattering_ref',
    'simple_spectrum':
        'simple_spectrum_ref'
}

# Complete filenames
reference_filenames = {
    key: os.path.join(tests_data_directory, value + '.npz')
    if key != 'config_test_radtrans' else
    os.path.join(tests_data_directory, value + '.json')
    for key, value in reference_filenames.items()
}

reference_filenames['mock_observation_transmission'] = (
    reference_filenames['correlated_k_transmission_cloud_calculated_radius_scattering'].rsplit('.', 1)[0]
    + '.dat'  # using a .dat file is needed for the basic retrieval test
)
reference_filenames['pymultinest_parameter_analysis'] = (
    os.path.join(tests_data_directory, 'test_stats.json')
)
reference_filenames['pymultinest_parameter_analysis_spectral_model'] = (
    os.path.join(tests_data_directory, 'test_spectral_model_stats.json')
)
reference_filenames['NASA_exoplanet_archive_test'] = (
    os.path.join(tests_data_directory, 'NASA_exoplanet_archive_test.tab')
)

# Make directories if needed
if not os.path.isdir(tests_results_directory):
    os.mkdir(tests_results_directory)


# Common parameters
def make_petitradtrans_test_config_file(filename):
    wavelength_range_correlated_k = [0.9, 1.2]
    wavelength_range_correlated_k_performance = [0.3, 28]
    wavelength_range_line_by_line = [2.3000, 2.3025]

    wavelength_min, wavelength_max = _get_max_wavelength_range(
        [wavelength_range_correlated_k, wavelength_range_line_by_line]
    )

    correlated_k_range = f"{wavelength_range_correlated_k[0]:.1f}-{wavelength_range_correlated_k[1]:.1f}mu"
    line_by_line_range = f"{wavelength_range_line_by_line[0]:.1f}-{wavelength_range_line_by_line[1]:.1f}mu"
    other_range = f"{wavelength_min:.1f}-{wavelength_max:.1f}mu"

    with open(os.path.join(filename), 'w') as f:
        json.dump(
            obj={
                'header': f'File generated by tests.utils function\n'
                          f'wavelength units: um\n'
                          f'pressure units: log10(bar), generate using numpy.logspace\n'
                          f'planet radius units: R_jup\n'
                          f'star radius units: R_sun\n'
                          f'metallicity units: log10(solar metallicity)\n'
                          f'angle units: deg\n'
                          f'other units: cgs',
                'prt_version': f'{version}',
                'pressures': {
                    'start': -6,
                    'stop': 2,
                    'stop_thin_atmosphere': 0,
                    'num': 27,
                    'num_performance': 100
                },
                'mass_fractions_correlated_k': {
                    'H2': 0.74,
                    'He': 0.24,
                    f'1H2-16O__HITEMP.R1000_{correlated_k_range}': 0.001,
                    f'12C-1H4__YT34to10.R1000_{correlated_k_range}': 0.001,
                    f'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': 0.0,
                    f'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': 0.0
                },
                'mass_fractions_line_by_line': {
                    'H2': 0.74,
                    'He': 0.24,
                    f'1H2-16O__POKAZATEL.R1e6_{line_by_line_range}': 0.001,
                    f'C-O-NatAbund__HITEMP.R1e6_{line_by_line_range}': 0.1,
                    f'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': 0.0,
                    f'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': 0.0
                },
                'mass_fractions_test': [1, -12],  # (log_10 MMR)
                'filling_species': {
                    'H2': 37,
                    'He': 12,
                    'Ne': 0.06
                },
                'mean_molar_mass': 2.33,  # (g.cm-3)
                'chemical_parameters': {
                    'metallicities': [-1.9, 0.0, 3.0],  # (log_10 solar)
                    'c_o_ratios': [0.1, 0.55, 1.6],
                    'pressure': 0.1,  # (bar)
                    'temperature': 900.0,  # (K)
                    'pressure_quench_carbon': 1.0  # (bar)
                },
                'temperature_isothermal': 1200.0,  # (K)
                'temperature_guillot_2010_parameters': {
                    'infrared_mean_opacity': 0.01,
                    'gamma': 0.4,
                    'intrinsic_temperature': 200.0,  # (K)
                    'equilibrium_temperature': 1500.0  # (K)
                },
                'planetary_parameters': {
                    'name': 'PSR B1257+12 b',  # actual planet has no link to below parameters
                    'reference_pressure': 0.01,  # (bar)
                    'radius': 1.838,  # (R_jup)
                    'reference_gravity': 1e1 ** 2.45,  # (cm.s-2)
                    'eddy_diffusion_coefficients': 10 ** 7.5,
                    'orbit_semi_major_axis': 7.5e11,  # (cm)
                    'orbital_period': 3600 * 24,  # (s)
                    'orbital_inclination': 88,  # (deg)
                    'transit_duration': 3600,  # (s)
                    'surface_reflectance': 0.3
                },
                'stellar_parameters': {
                    'effective_temperature': 5778.0,  # (K)
                    'radius': 1.0,  # (R_sun)
                    'mass': 1.0,  # (M_sun)
                    'incidence_angle': 30,  # (deg)
                    'system_distance': 10  # (ly)
                },
                'spectrum_parameters': {
                    'line_by_line_opacity_sampling': 4,
                    'line_species_correlated_k': [
                        f'1H2-16O__HITEMP.R1000_{correlated_k_range}',
                        f'12C-1H4__YT34to10.R1000_{correlated_k_range}'
                    ],
                    'line_species_line_by_line': [
                        f'1H2-16O__POKAZATEL.R1e6_{line_by_line_range}',
                        f'C-O-NatAbund__HITEMP.R1e6_{line_by_line_range}'
                    ],
                    'rayleigh_species': [
                        'H2',
                        'He'
                    ],
                    'continuum_opacities': [
                        f"H2--H2-NatAbund__BoRi.R831_{other_range}",
                        f"H2--He-NatAbund__BoRi.DeltaWavenumber2_{other_range}"
                    ],
                    'wavelength_range_correlated_k': wavelength_range_correlated_k,
                    'wavelength_range_correlated_k_performance': wavelength_range_correlated_k_performance,
                    'wavelength_range_line_by_line': wavelength_range_line_by_line
                },
                'cloud_parameters': {
                    'kappa_zero': 0.01,
                    'gamma_scattering': -4.0,
                    'cloud_pressure': 0.01,
                    'haze_factor': 10.0,
                    'cloud_fraction': 0.67,
                    'complete_coverage_clouds': 0,  # index of the cloud species that must have complete coverage
                    'cloud_species': {
                        f'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': {
                            'mass_fraction': 5e-7,
                            'radius': 5e-5,  # (cm)
                            'f_sed': 2.0,
                            'f_sed_variable_setup': [2.0, 2.5],  # linearly changes from 1 at bottom to 5 at top
                            'sigma_log_normal': 1.05,
                            'b_hansen': 0.01
                        },
                        f'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_{other_range}': {
                            'mass_fraction': 3e-7,
                            'radius': 4e-5,  # (cm)
                            'f_sed': 3.0,
                            'f_sed_variable_setup': [2.0, 2.5],  # linearly changes from 1 at bottom to 5 at top
                            'sigma_log_normal': 1.2,
                            'b_hansen': 0.02
                        },
                    }
                },
                'retrieval_parameters': {
                    'planetary_radius_bounds': (1.8, 2.0),
                    'intrinsic_temperature_bounds': (500, 1500),
                    'log10_cloud_pressure_bounds': (-6, 2),
                    'log10_species_mass_fractions_bounds': (-6, -1),
                    'radial_velocity_semi_amplitude_bounds': (100e5, 200e5),
                    'rest_frame_velocity_shift_bounds': (-10e5, 10e5),
                    'mid_transit_time_bounds': (-600, 600),
                    'sample_spectrum_output': False,
                    'ultranest': False,
                    'sampling_efficiency': 0.8,
                    'n_live_points': 50,
                    'n_live_points_spectral_model': 15,
                    'const_efficiency_mode': False,
                    'resume': False,
                    'seed': 12345
                },
                'mock_observation_parameters': {
                    'resolving_power': 60,
                    'high_resolution_resolving_power': 1e5,
                    'wavelength_range_high_resolution': (2.3005, 2.3020),
                    'orbital_phase_range': (-1e-2, 1e-2),
                    'system_observer_radial_velocities_range': (-5.0e5, -4.85e5),
                    'n_exposures': 20,
                    'rest_frame_velocity_shift': -1.5e5,
                    'relative_error': 1e-2
                },
                'preparing_parameters': {
                    'tellurics_mask_threshold': 0.8,
                    'polynomial_fit_degree': 2
                },
                'ccf_analysis_parameters': {
                    'normalize_ccf': True,
                    'calculate_ccf_snr': True,
                    'ccf_sum_axes': (0,),
                    'pixels_per_resolution_element': 2,
                    'peak_lsf_factor': 1.5,
                    'velocity_interval_extension_factor': -0.3,
                    'kp_factor': 1.5,
                    'peak_cutoff': 0.68
                }
            },
            fp=f,
            indent=4
        )


def make_test_opacities():
    import h5py
    from petitRADTRANS.__file_conversion import (
        write_cia_opacities, write_cloud_opacities, write_correlated_k, write_line_by_line
    )

    from petitRADTRANS.opacities.opacities import (
        Opacity, CIAOpacity, CloudOpacity, CorrelatedKOpacity, LineByLineOpacity
    )
    from petitRADTRANS.spectral_model import SpectralModel

    def __update_file_wavelength_range(_hdf5_file, _wavelength_min, _wavelength_max, _file_extension):
        hdf5_opacity_file, spectral_information = Opacity.split_species_spectral_info(_hdf5_file)
        resolution_filename, range_filename = Opacity.find_spectral_information(spectral_information)

        range_filename = f"{_wavelength_min * 1e4:.1f}-{_wavelength_max * 1e4:.1f}mu"  # cm to um

        return f"{hdf5_opacity_file}.{resolution_filename}_{range_filename}.{_file_extension}"

    def __write_test_cia_opacities():
        file_extension = CIAOpacity.get_default_extension()

        for species in parameters['spectrum_parameters'][opacity_type]:
            species, _ = Opacity.split_species_spectral_info(species)  # use default

            hdf5_file = CIAOpacity.find(
                species=species
            )

            (
                doi,
                species,
                wavenumbers,
                alpha,
                temperatures
            ) = SpectralModel.load_cia_opacity(hdf5_file, return_radtrans_opacities=False)

            selected_wavenumbers = 1 / wavenumbers[::-1]  # cm-1 to um, increasing order

            selection = np.nonzero(np.logical_and(
                np.greater_equal(selected_wavenumbers, wavelength_min),
                np.less_equal(selected_wavenumbers, wavelength_max)
            ))[0]

            selection = np.concatenate(  # ensure that the boundaries are within the selection
                (np.array([selection[0] - 2]),  # extra point for the interpolation
                 selection,
                 np.array([selection[-1] + 1]))
            )

            selected_wavenumbers = wavenumbers[::-1][selection][::-1]

            selection = np.nonzero(np.logical_and(
                np.greater_equal(
                    wavenumbers,
                    selected_wavenumbers[0]
                ),
                np.less_equal(
                    wavenumbers,
                    selected_wavenumbers[-1]
                )
            ))[0]

            hdf5_file = __update_file_wavelength_range(
                _hdf5_file=hdf5_file,
                _wavelength_min=wavelength_min,
                _wavelength_max=wavelength_max,
                _file_extension=file_extension
            )

            print(f"Writing file {hdf5_file}...", end=' ')

            species = [s.decode('utf-8') for s in species]

            write_cia_opacities(
                hdf5_cia_file=hdf5_file,
                molecules=species,
                wavenumbers=wavenumbers[selection],
                wavelengths=1e4 / wavenumbers[selection],  # cm-1 to um
                alpha=alpha[:, selection],
                temperatures=temperatures,
                doi=doi,
                description=description
            )

            print(f"Done.")

    def __write_test_cloud_opacities():
        file_extension = CloudOpacity.get_default_extension()

        for species in parameters['cloud_parameters'][opacity_type]:
            species, _ = Opacity.split_species_spectral_info(species)  # use default

            hdf5_file = CloudOpacity.find(
                species=species
            )

            (
                wavenumbers,
                cloud_particles_radius_bins,
                cloud_particles_radii,
                cloud_particles_densities,
                cloud_absorption_opacities,
                cloud_scattering_opacities,
                cloud_asymmetry_parameters
            ) = SpectralModel.load_cloud_opacity(hdf5_file, return_radtrans_opacities=False)

            with h5py.File(hdf5_file, 'r') as f:
                doi = f['DOI'][()]

            selected_wavenumbers = 1 / wavenumbers[::-1]  # cm-1 to um, increasing order

            selection = np.nonzero(np.logical_and(
                np.greater_equal(selected_wavenumbers, wavelength_min),
                np.less_equal(selected_wavenumbers, wavelength_max)
            ))[0]

            selection = np.concatenate(  # ensure that the boundaries are within the selection
                (np.array([selection[0] - 1]), selection, np.array([selection[-1] + 1]))
            )

            selected_wavenumbers = wavenumbers[::-1][selection][::-1]

            selection = np.nonzero(np.logical_and(
                np.greater_equal(
                    wavenumbers,
                    selected_wavenumbers[0]
                ),
                np.less_equal(
                    wavenumbers,
                    selected_wavenumbers[-1]
                )
            ))[0]

            cloud_species, _ = Opacity.split_species_spectral_info(hdf5_file)

            hdf5_file = __update_file_wavelength_range(
                _hdf5_file=hdf5_file,
                _wavelength_min=wavelength_min,
                _wavelength_max=wavelength_max,
                _file_extension=file_extension
            )

            print(f"Writing file {hdf5_file}...", end=' ')

            write_cloud_opacities(
                hdf5_opacity_file=hdf5_file,
                cloud_species=cloud_species,
                wavenumbers=wavenumbers[selection],
                cloud_wavelengths=1e4 / wavenumbers[selection][::-1],  # cm-1 to um
                cloud_absorption_opacities=cloud_absorption_opacities[:, selection],
                cloud_scattering_opacities=cloud_scattering_opacities[:, selection],
                cloud_asymmetry_parameter=cloud_asymmetry_parameters[:, selection],
                cloud_particles_densities=cloud_particles_densities,
                cloud_particles_radii=cloud_particles_radii,
                cloud_particles_radius_bins=cloud_particles_radius_bins,
                doi=doi,
                description=description
            )

            print(f"Done.")

    def __write_test_correlated_k_opacities():
        file_extension = CorrelatedKOpacity.get_default_extension()
        _wavelength_min = parameters['spectrum_parameters']['wavelength_range_correlated_k'][0]
        _wavelength_max = parameters['spectrum_parameters']['wavelength_range_correlated_k'][1]

        for species in parameters['spectrum_parameters'][opacity_type]:
            species, _ = Opacity.split_species_spectral_info(species)  # use default

            hdf5_file = CorrelatedKOpacity.find(
                species=species
            )

            (
                doi,
                bin_centers,
                bin_edges,
                k_table,
                mol_mass,
                species,
                pressures,
                temperatures,
                samples,
                weights
            ) = SpectralModel.load_hdf5_ktables(
                file_path_hdf5=hdf5_file,
                frequencies=None,
                g_size=None,
                temperature_pressure_grid_size=None,
                return_radtrans_opacities=False
            )

            selected_wavenumbers = 1e4 / bin_edges[::-1]  # cm-1 to um, increasing order

            selection = np.nonzero(np.logical_and(
                np.greater_equal(
                    selected_wavenumbers,
                    _wavelength_min
                ),
                np.less_equal(
                    selected_wavenumbers,
                    _wavelength_max
                )  # cm-1 to um
            ))[0]

            selection = np.concatenate(  # ensure that the boundaries are within the selection
                (np.array([selection[0] - 1]), selection, np.array([selection[-1] + 1]))
            )

            selected_wavenumbers = bin_edges[::-1][selection][::-1]

            selection = np.nonzero(np.logical_and(
                np.greater_equal(bin_centers, selected_wavenumbers[0]),
                np.less_equal(bin_centers, selected_wavenumbers[-1])
            ))[0]

            hdf5_file = __update_file_wavelength_range(
                _hdf5_file=hdf5_file,
                _wavelength_min=_wavelength_min * 1e-4,  # um to cm (converted back to um inside the function)
                _wavelength_max=_wavelength_max * 1e-4,  # um to cm (converted back to um inside the function)
                _file_extension=file_extension
            )

            print(f"Writing file {hdf5_file}...", end=' ')

            write_correlated_k(
                file=hdf5_file,
                doi=doi,
                wavenumbers=bin_centers[selection],
                wavenumbers_bins_edges=selected_wavenumbers,
                cross_sections=k_table[:, :, selection, :],
                mol_mass=mol_mass,
                species=species,
                opacities_pressures=pressures,
                opacities_temperatures=temperatures,
                g_gauss=samples,
                weights_gauss=weights,
                description=description
            )

            print(f"Done.")

    def __write_test_line_by_line_opacities():
        file_extension = LineByLineOpacity.get_default_extension()

        for species in line_species:
            hdf5_file = LineByLineOpacity.find(
                species=species
            )

            (
                doi,
                bin_edges,
                cross_sections,
                mol_mass,
                species,
                pressures,
                temperatures
            ) = SpectralModel.load_hdf5_line_opacity_table(
                file_path_hdf5=hdf5_file,
                frequencies=None,
                line_by_line_opacity_sampling=1,
                return_radtrans_opacities=False
            )

            selected_wavenumbers = 1e4 / bin_edges[::-1]  # cm-1 to um, increasing order

            selection = np.nonzero(np.logical_and(
                np.greater_equal(
                    selected_wavenumbers,
                    spectral_model.wavelength_boundaries[0]
                    #parameters['spectrum_parameters']['wavelength_range_line_by_line'][0]
                ),
                np.less_equal(
                    selected_wavenumbers,
                    spectral_model.wavelength_boundaries[1]
                    #parameters['spectrum_parameters']['wavelength_range_line_by_line'][1]
                )  # cm-1 to um
            ))[0]

            selection = np.concatenate(  # ensure that the boundaries are within the selection
                (np.array([selection[0] - 1 - parameters['spectrum_parameters']['line_by_line_opacity_sampling']]),
                 selection,
                 np.array([selection[-1] + 1 + parameters['spectrum_parameters']['line_by_line_opacity_sampling']]))
            )

            selected_wavenumbers = bin_edges[::-1][selection][::-1]

            selection = np.nonzero(np.logical_and(
                np.greater_equal(
                    bin_edges,
                    selected_wavenumbers[0]
                ),
                np.less_equal(
                    bin_edges,
                    selected_wavenumbers[-1]
                )
            ))[0]

            hdf5_file = __update_file_wavelength_range(
                _hdf5_file=hdf5_file,
                _wavelength_min=parameters['spectrum_parameters']['wavelength_range_line_by_line'][0] * 1e-4,
                _wavelength_max=parameters['spectrum_parameters']['wavelength_range_line_by_line'][1] * 1e-4,
                _file_extension=file_extension
            )

            print(f"Writing file {hdf5_file}...", end=' ')

            print(1e4/bin_edges[selection][::-1])
            print(bin_edges[selection])

            write_line_by_line(
                file=hdf5_file,
                doi=doi,
                wavenumbers=bin_edges[selection],
                opacities=cross_sections[:, :, selection],
                mol_mass=mol_mass,
                species=species,
                opacities_pressures=pressures,
                opacities_temperatures=temperatures,
                description=description
            )

            print(f"Done.")

    with open(reference_filenames['config_test_radtrans'], 'r') as f:
        parameters = json.load(f)

    description = 'Truncated opacity intended for testing petitRADTRANS'

    line_species = [
        Opacity.split_species_spectral_info(s)[0]
        for s in parameters['spectrum_parameters']['line_species_line_by_line']
    ]

    spectral_model = petitRADTRANS.spectral_model.SpectralModel(
        # Radtrans parameters
        pressures=test_parameters['pressures'],
        line_species=test_parameters['spectrum_parameters']['line_species_line_by_line'],
        rayleigh_species=test_parameters['spectrum_parameters']['rayleigh_species'],
        gas_continuum_contributors=test_parameters['spectrum_parameters']['continuum_opacities'],
        line_opacity_mode='lbl',
        orbital_period=test_parameters['planetary_parameters']['orbital_period'],
        star_mass=test_parameters['stellar_parameters']['radius'] * petitRADTRANS.physical_constants.m_sun,  # g
        orbit_semi_major_axis=test_parameters['planetary_parameters']['orbit_semi_major_axis'],  # cm
        orbital_inclination=test_parameters['planetary_parameters']['orbital_inclination'],
        rest_frame_velocity_shift=test_parameters['mock_observation_parameters'][
            "rest_frame_velocity_shift"],  # cm.s-1
        system_observer_radial_velocities=np.linspace(
            test_parameters['mock_observation_parameters']['system_observer_radial_velocities_range'][0],
            test_parameters['mock_observation_parameters']['system_observer_radial_velocities_range'][1],
            test_parameters['mock_observation_parameters']['n_exposures']
        ),  # cm.s-1
        rebinned_wavelengths=petitRADTRANS.math.resolving_space(
            test_parameters['spectrum_parameters']['wavelength_range_line_by_line'][0] * 1e-4,
            test_parameters['spectrum_parameters']['wavelength_range_line_by_line'][1] * 1e-4,
            test_parameters['mock_observation_parameters']['high_resolution_resolving_power']
        ),  # (cm) used for the rebinning, and also to set the wavelengths boundaries
        rebin_range_margin_power=3,  # TODO this should not be necessary
        convolve_resolving_power=test_parameters['mock_observation_parameters']['high_resolution_resolving_power'],
        mid_transit_time=0,
        times=2 * test_parameters['planetary_parameters']['transit_duration'] * (
                np.linspace(0, 1, test_parameters['mock_observation_parameters']['n_exposures']) - 0.5),
    )

    test_wavelength_ranges = [
        spectral_model.wavelength_boundaries,
        parameters['spectrum_parameters']['wavelength_range_correlated_k'],
        parameters['spectrum_parameters']['wavelength_range_line_by_line']
    ]

    wavelength_min, wavelength_max = _get_max_wavelength_range(test_wavelength_ranges)

    wavelength_min *= 1e-4  # um to cm
    wavelength_max *= 1e-4  # um to cm

    opacity_types = (
        'line_species_correlated_k',
        'line_species_line_by_line',
        'continuum_opacities',
        'cloud_species'
    )

    for opacity_type in opacity_types:
        if opacity_type == 'cloud_species':
            __write_test_cloud_opacities()
        elif opacity_type == 'line_species_correlated_k':
            __write_test_correlated_k_opacities()
        elif opacity_type == 'line_species_line_by_line':
            __write_test_line_by_line_opacities()
        elif opacity_type == 'continuum_opacities':
            __write_test_cia_opacities()
        else:
            raise NotImplementedError(f"making opacity files for opacity type '{opacity_type}' is not handled")

    print('Done')


def init_test_parameters(recreate_parameter_file=False):
    """
    Initialize various parameters used both to perform the tests and generate the reference files.
    Do not change these parameters when comparing with a previous version.
    """
    if not os.path.isfile(reference_filenames['config_test_radtrans']) or recreate_parameter_file:
        print('Generating Radtrans test parameters file...')
        make_petitradtrans_test_config_file(filename=reference_filenames['config_test_radtrans'])

    with open(reference_filenames['config_test_radtrans'], 'r') as f:
        parameters = json.load(f)

    parameters['pressures_thin_atmosphere'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop_thin_atmosphere'],
        parameters['pressures']['num']
    )

    parameters['pressures_performance'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop'],
        parameters['pressures']['num_performance']
    )

    parameters['pressures'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop'],
        parameters['pressures']['num']
    )

    for key in parameters['mass_fractions_correlated_k']:
        parameters['mass_fractions_correlated_k'][key] *= np.ones_like(parameters['pressures'])

    for key in parameters['mass_fractions_line_by_line']:
        parameters['mass_fractions_line_by_line'][key] *= np.ones_like(parameters['pressures'])

    parameters['mean_molar_mass'] *= np.ones_like(parameters['pressures'])
    parameters['planetary_parameters']['eddy_diffusion_coefficients'] *= np.ones_like(parameters['pressures'])

    parameters['cloud_parameters']['complete_coverage_clouds'] = ([
        list(parameters['cloud_parameters']['cloud_species'].keys())[
            parameters['cloud_parameters']['complete_coverage_clouds']
        ]
    ])

    return parameters


def update_petitradtrans_test_config_file():
    print('Updating Radtrans test parameters file...', end=' ')
    make_petitradtrans_test_config_file(filename=reference_filenames['config_test_radtrans'])
    print('Done.')

test_parameters = init_test_parameters()


# Useful functions
def _get_max_wavelength_range(wavelength_ranges):
    wavelength_min = np.inf
    wavelength_max = -np.inf

    for test_wavelength_range in wavelength_ranges:
        test_wavelength_min = np.min(test_wavelength_range)
        test_wavelength_max = np.max(test_wavelength_range)

        if wavelength_min > test_wavelength_min:
            wavelength_min = test_wavelength_min

        if wavelength_max < test_wavelength_max:
            wavelength_max = test_wavelength_max

    return wavelength_min, wavelength_max


def check_cloud_mass_fractions():
    """
    Check if cloud mass fraction is set to 0 by default.
    This is necessary to correctly assess the effect of the different clear and cloud models.
    """
    for species, mmr in test_parameters['mass_fractions_correlated_k'].items():
        if '(c)' in species or '(l)' in species or '(s)' in species or '(cr)' in species:  # condensed species
            if not np.all(mmr == 0):
                raise ValueError(
                    f"cloud {species} has a default mass fraction different of 0, cannot perform test\n"
                    f"mass fraction was: {mmr}"
                )

    for species, mmr in test_parameters['mass_fractions_line_by_line'].items():
        if '(c)' in species or '(l)' in species or '(s)' in species or '(cr)' in species:  # condensed species
            if not np.all(mmr == 0):
                raise ValueError(
                    f"cloud {species} has a default mass fraction different of 0, cannot perform test\n"
                    f"mass fraction was: {mmr}"
                )


def check_cloud_complete_coverage_consistency(spectrum_function, benchmark, relative_tolerance,
                                              cloud_fraction, complete_coverage_clouds, mass_fractions,
                                              mass_fractions_clear=None,
                                              opaque_cloud_top_pressure=None, **kwargs):
    """Check if results obtained with partial cloud coverage are consistent."""
    if mass_fractions_clear is None:
        mass_fractions_clear = mass_fractions

    if opaque_cloud_top_pressure is not None:
        opaque_cloud_top_pressure_clear = None
    else:
        opaque_cloud_top_pressure_clear = opaque_cloud_top_pressure

    # Test flux cloudy
    print('Testing cloudy transit radii consistency...', end=' ')
    _, flux_cloudy, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        complete_coverage_clouds=None,
        **kwargs
    )

    _, flux_coverage1, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    assert np.allclose(
        flux_cloudy,
        flux_coverage1,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    # Test flux clear
    print('Testing clear transit radii consistency...', end=' ')
    _, flux_clear, _ = spectrum_function(
        mass_fractions=mass_fractions_clear,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure_clear,
        complete_coverage_clouds=None,
        **kwargs
    )

    _, flux_coverage0, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=0,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    assert np.allclose(
        flux_clear,
        flux_coverage0,
        atol=0,
        rtol=relative_tolerance
    )

    assert not np.allclose(  # check that there are differences between the cloudy and the cloudless cases
        flux_clear,
        flux_cloudy,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    benchmark.run(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=cloud_fraction,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    # Test flux with cloud fraction
    print('Testing transit radii with partial cloud coverage consistency...', end=' ')
    reference_file = benchmark._load_reference_file()

    assert np.allclose(
        test_parameters['cloud_parameters']['cloud_fraction'] * flux_cloudy
        + (1 - test_parameters['cloud_parameters']['cloud_fraction']) * flux_clear,
        reference_file.outputs['1'],
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')


def check_partial_cloud_coverage_full_consistency(spectrum_function, benchmark, relative_tolerance,
                                                  cloud_fraction, mass_fractions, mass_fractions_clear=None,
                                                  opaque_cloud_top_pressure=None, **kwargs):
    """Check if results obtained with partial cloud coverage are consistent."""
    if mass_fractions_clear is None:
        mass_fractions_clear = mass_fractions

    if opaque_cloud_top_pressure is not None:
        opaque_cloud_top_pressure_clear = None
    else:
        opaque_cloud_top_pressure_clear = opaque_cloud_top_pressure

    # Test flux cloudy
    print('Testing cloudy transit radii consistency...', end=' ')
    _, flux_cloudy, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        **kwargs
    )

    _, flux_coverage1, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        **kwargs
    )

    assert np.allclose(
        flux_cloudy,
        flux_coverage1,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    # Test flux clear
    print('Testing clear transit radii consistency...', end=' ')
    _, flux_clear, _ = spectrum_function(
        mass_fractions=mass_fractions_clear,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure_clear,
        **kwargs
    )

    _, flux_coverage0, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=0,
        **kwargs
    )

    assert np.allclose(
        flux_clear,
        flux_coverage0,
        atol=0,
        rtol=relative_tolerance
    )

    assert not np.allclose(  # check that there are differences between the cloudy and the cloudless cases
        flux_clear,
        flux_cloudy,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    benchmark.run(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=cloud_fraction,
        **kwargs
    )

    # Test flux with cloud fraction
    print('Testing transit radii with partial cloud coverage consistency...', end=' ')
    reference_file = benchmark._load_reference_file()

    assert np.allclose(
        test_parameters['cloud_parameters']['cloud_fraction'] * flux_cloudy
        + (1 - test_parameters['cloud_parameters']['cloud_fraction']) * flux_clear,
        reference_file.outputs['1'],
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

def get_cloud_parameters(mass_fraction_type, filling_species=None):
    mass_fractions = copy.deepcopy(test_parameters[mass_fraction_type])
    cloud_particles_mean_radii = {}
    cloud_f_sed = {}
    cloud_particle_radius_distribution_std = None
    cloud_b_hansen = {}

    for cloud, parameters in test_parameters['cloud_parameters']['cloud_species'].items():
        mass_fractions[cloud] = parameters['mass_fraction']
        cloud_particles_mean_radii[cloud] = parameters['radius']
        cloud_f_sed[cloud] = parameters['f_sed']
        cloud_b_hansen = parameters['b_hansen']

        if cloud_particle_radius_distribution_std is None:
            cloud_particle_radius_distribution_std = parameters['sigma_log_normal']

    if filling_species is not None:
        for species in filling_species:
            if species in mass_fractions:
                del mass_fractions[species]

    return (
        mass_fractions, cloud_particles_mean_radii, cloud_f_sed, cloud_particle_radius_distribution_std, cloud_b_hansen
    )

def get_main_model_parameters(spectral_model, **kwargs):
    """Calculate a SpectralModel spectrum and return the temperatures, mass fractions and mean molar masses in
    addition to wavelengths and spectra."""
    wavelengths, spectra = spectral_model.calculate_spectrum(**kwargs)

    return (wavelengths, spectra,
            spectral_model.temperatures, spectral_model.mass_fractions, spectral_model.mean_molar_masses)


# Initializations
def init_guillot_2010_temperature_profile():
    temperature_guillot = petitRADTRANS.physics.temperature_profile_function_guillot_global(
        pressures=test_parameters['pressures'],
        infrared_mean_opacity=test_parameters['temperature_guillot_2010_parameters']['infrared_mean_opacity'],
        gamma=test_parameters['temperature_guillot_2010_parameters']['gamma'],
        gravities=test_parameters['planetary_parameters']['reference_gravity'],
        intrinsic_temperature=test_parameters['temperature_guillot_2010_parameters']['intrinsic_temperature'],
        equilibrium_temperature=test_parameters['temperature_guillot_2010_parameters']['equilibrium_temperature']
    )

    return temperature_guillot


def init_radtrans_test():
    check_cloud_mass_fractions()

    tp_iso = test_parameters['temperature_isothermal'] * np.ones_like(test_parameters['pressures'])
    tp_guillot_2010 = init_guillot_2010_temperature_profile()

    return tp_iso, tp_guillot_2010

temperature_isothermal, temperature_guillot_2010 = init_radtrans_test()
