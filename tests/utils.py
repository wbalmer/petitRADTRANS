"""Utility functions for tests.

Regenerate the comparison files only when changing the precision of the models.
"""
import copy
import json
import os

import numpy as np

from .context import petitRADTRANS

version = "3.1.0"  # petitRADTRANS.version.version used to generate last tests

tests_data_directory = os.path.join(os.path.dirname(__file__), 'data')
tests_references_directory = os.path.join(os.path.dirname(__file__), 'references')
tests_error_directory = os.path.join(os.path.dirname(__file__), 'errors')
tests_results_directory = os.path.join(os.path.dirname(__file__), 'results')
reference_filenames = {
    'config_test_radtrans':
        'config_test_radtrans',
    'guillot_2010':
        'radtrans_guillot_2010_temperature_profile_ref',
    'correlated_k_transmission_cloud_calculated_radius_scattering':
        'radtrans_correlated_k_transmission_cloud_calculated_radius_scattering_ref',
    'simple_spectrum':
        'simple_spectrum_ref'
}

# Complete filenames
reference_filenames = {
    key: os.path.join(tests_data_directory, value + '.npz')
    if key != 'config_test_radtrans' else
    os.path.join(tests_data_directory, value + '.json')
    for key, value in reference_filenames.items()
}

reference_filenames['mock_observation_transmission'] = (
    reference_filenames['correlated_k_transmission_cloud_calculated_radius_scattering'].rsplit('.', 1)[0]
    + '.dat'  # using a .dat file is needed for the basic retrieval test
)
reference_filenames['pymultinest_parameter_analysis'] = (
    os.path.join(tests_data_directory, 'test_stats.json')
)
reference_filenames['pymultinest_parameter_analysis_spectral_model'] = (
    os.path.join(tests_data_directory, 'test_spectral_model_stats.json')
)
reference_filenames['NASA_exoplanet_archive_test'] = (
    os.path.join(tests_data_directory, 'NASA_exoplanet_archive_test.tab')
)

# Make directories if needed
if not os.path.isdir(tests_results_directory):
    os.mkdir(tests_results_directory)


# Common parameters
def make_petitradtrans_test_config_file(filename):
    with open(os.path.join(filename), 'w') as f:
        json.dump(
            obj={
                'header': f'File generated by tests.utils function\n'
                          f'wavelength units: um\n'
                          f'pressure units: log10(bar), generate using numpy.logspace\n'
                          f'planet radius units: R_jup\n'
                          f'star radius units: R_sun\n'
                          f'metallicity units: log10(solar metallicity)\n'
                          f'angle units: deg\n'
                          f'other units: cgs',
                'prt_version': f'{version}',
                'pressures': {
                    'start': -6,
                    'stop': 2,
                    'stop_thin_atmosphere': 0,
                    'num': 27,
                    'num_performance': 100
                },
                'mass_fractions_correlated_k': {
                    'H2': 0.74,
                    'He': 0.24,
                    '1H2-16O__HITEMP.R1000_0.1-250mu': 0.001,
                    '12C-1H4__YT34to10.R1000_0.3-50mu': 0.001,
                    'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': 0.0,
                    'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': 0.0
                },
                'mass_fractions_line_by_line': {
                    'H2': 0.74,
                    'He': 0.24,
                    '1H2-16O__POKAZATEL.R1e6_0.3-28mu': 0.001,
                    'C-O-NatAbund__HITEMP.R1e6_0.3-28mu': 0.1,
                    'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': 0.0,
                    'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': 0.0
                },
                'mass_fractions_test': [1, -12],  # (log_10 MMR)
                'filling_species': {
                    'H2': 37,
                    'He': 12,
                    'Ne': 0.06
                },
                'mean_molar_mass': 2.33,  # (g.cm-3)
                'chemical_parameters': {
                    'metallicities': [-1.9, 0.0, 3.0],  # (log_10 solar)
                    'c_o_ratios': [0.1, 0.55, 1.6],
                    'pressure': 0.1,  # (bar)
                    'temperature': 900.0,  # (K)
                    'pressure_quench_carbon': 1.0  # (bar)
                },
                'temperature_isothermal': 1200.0,  # (K)
                'temperature_guillot_2010_parameters': {
                    'infrared_mean_opacity': 0.01,
                    'gamma': 0.4,
                    'intrinsic_temperature': 200.0,  # (K)
                    'equilibrium_temperature': 1500.0  # (K)
                },
                'planetary_parameters': {
                    'name': 'PSR B1257+12 b',  # actual planet has no link to below parameters
                    'reference_pressure': 0.01,  # (bar)
                    'radius': 1.838,  # (R_jup)
                    'reference_gravity': 1e1 ** 2.45,  # (cm.s-2)
                    'eddy_diffusion_coefficients': 10 ** 7.5,
                    'orbit_semi_major_axis': 7.5e11,  # (cm)
                    'orbital_period': 3600 * 24,  # (s)
                    'orbital_inclination': 88,  # (deg)
                    'transit_duration': 3600,  # (s)
                    'surface_reflectance': 0.3
                },
                'stellar_parameters': {
                    'effective_temperature': 5778.0,  # (K)
                    'radius': 1.0,  # (R_sun)
                    'mass': 1.0,  # (M_sun)
                    'incidence_angle': 30,  # (deg)
                    'system_distance': 10  # (ly)
                },
                'spectrum_parameters': {
                    'line_by_line_opacity_sampling': 4,
                    'line_species_correlated_k': [
                        '1H2-16O__HITEMP.R1000_0.1-250mu',
                        '12C-1H4__YT34to10.R1000_0.3-50mu'
                    ],
                    'line_species_line_by_line': [
                        '1H2-16O__POKAZATEL.R1e6_0.3-28mu',
                        'C-O-NatAbund__HITEMP.R1e6_0.3-28mu'
                    ],
                    'rayleigh_species': [
                        'H2',
                        'He'
                    ],
                    'continuum_opacities': [
                        "H2--H2-NatAbund__BoRi.R831_0.6-250mu",
                        "H2--He-NatAbund__BoRi.DeltaWavenumber2_0.5-500mu"
                    ],
                    'wavelength_range_correlated_k': [0.9, 1.2],
                    'wavelength_range_correlated_k_performance': [0.3, 28],
                    'wavelength_range_line_by_line': [2.3000, 2.3025]
                },
                'cloud_parameters': {
                    'kappa_zero': 0.01,
                    'gamma_scattering': -4.0,
                    'cloud_pressure': 0.01,
                    'haze_factor': 10.0,
                    'cloud_fraction': 0.67,
                    'complete_coverage_clouds': 0,  # index of the cloud species that must have complete coverage
                    'cloud_species': {
                        'Mg2-Si-O4-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': {
                            'mass_fraction': 5e-7,
                            'radius': 5e-5,  # (cm)
                            'f_sed': 2.0,
                            'f_sed_variable_setup': [2.0, 2.5],  # linearly changes from 1 at bottom to 5 at top
                            'sigma_log_normal': 1.05,
                            'b_hansen': 0.01
                        },
                        'Mg-Si-O3-NatAbund(s)_crystalline_000__DHS.R39_0.1-250mu': {
                            'mass_fraction': 3e-7,
                            'radius': 4e-5,  # (cm)
                            'f_sed': 3.0,
                            'f_sed_variable_setup': [2.0, 2.5],  # linearly changes from 1 at bottom to 5 at top
                            'sigma_log_normal': 1.2,
                            'b_hansen': 0.02
                        },
                    }
                },
                'retrieval_parameters': {
                    'planetary_radius_bounds': (1.8, 2.0),
                    'intrinsic_temperature_bounds': (500, 1500),
                    'log10_cloud_pressure_bounds': (-6, 2),
                    'log10_species_mass_fractions_bounds': (-6, -1),
                    'radial_velocity_semi_amplitude_bounds': (100e5, 200e5),
                    'rest_frame_velocity_shift_bounds': (-10e5, 10e5),
                    'mid_transit_time_bounds': (-600, 600),
                    'sample_spectrum_output': False,
                    'ultranest': False,
                    'sampling_efficiency': 0.8,
                    'n_live_points': 50,
                    'n_live_points_spectral_model': 15,
                    'const_efficiency_mode': False,
                    'resume': False,
                    'seed': 12345
                },
                'mock_observation_parameters': {
                    'resolving_power': 60,
                    'high_resolution_resolving_power': 1e5,
                    'wavelength_range_high_resolution': (2.3005, 2.3020),
                    'orbital_phase_range': (-1e-2, 1e-2),
                    'system_observer_radial_velocities_range': (-5.0e5, -4.85e5),
                    'n_exposures': 20,
                    'rest_frame_velocity_shift': -1.5e5,
                    'relative_error': 1e-2
                },
                'preparing_parameters': {
                    'tellurics_mask_threshold': 0.8,
                    'polynomial_fit_degree': 2
                },
                'ccf_analysis_parameters': {
                    'normalize_ccf': True,
                    'calculate_ccf_snr': True,
                    'ccf_sum_axes': (0,),
                    'pixels_per_resolution_element': 2,
                    'peak_lsf_factor': 1.5,
                    'velocity_interval_extension_factor': -0.3,
                    'kp_factor': 1.5,
                    'peak_cutoff': 0.68
                }
            },
            fp=f,
            indent=4
        )


def init_test_parameters(recreate_parameter_file=False):
    """
    Initialize various parameters used both to perform the tests and generate the reference files.
    Do not change these parameters when comparing with a previous version.
    """
    if not os.path.isfile(reference_filenames['config_test_radtrans']) or recreate_parameter_file:
        print('Generating Radtrans test parameters file...')
        make_petitradtrans_test_config_file(filename=reference_filenames['config_test_radtrans'])

    with open(reference_filenames['config_test_radtrans'], 'r') as f:
        parameters = json.load(f)

    parameters['pressures_thin_atmosphere'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop_thin_atmosphere'],
        parameters['pressures']['num']
    )

    parameters['pressures_performance'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop'],
        parameters['pressures']['num_performance']
    )

    parameters['pressures'] = np.logspace(
        parameters['pressures']['start'],
        parameters['pressures']['stop'],
        parameters['pressures']['num']
    )

    for key in parameters['mass_fractions_correlated_k']:
        parameters['mass_fractions_correlated_k'][key] *= np.ones_like(parameters['pressures'])

    for key in parameters['mass_fractions_line_by_line']:
        parameters['mass_fractions_line_by_line'][key] *= np.ones_like(parameters['pressures'])

    parameters['mean_molar_mass'] *= np.ones_like(parameters['pressures'])
    parameters['planetary_parameters']['eddy_diffusion_coefficients'] *= np.ones_like(parameters['pressures'])

    parameters['cloud_parameters']['complete_coverage_clouds'] = ([
        list(parameters['cloud_parameters']['cloud_species'].keys())[
            parameters['cloud_parameters']['complete_coverage_clouds']
        ]
    ])

    return parameters


test_parameters = init_test_parameters()


# Useful functions
def check_cloud_mass_fractions():
    """
    Check if cloud mass fraction is set to 0 by default.
    This is necessary to correctly assess the effect of the different clear and cloud models.
    """
    for species, mmr in test_parameters['mass_fractions_correlated_k'].items():
        if '(c)' in species or '(l)' in species or '(s)' in species or '(cr)' in species:  # condensed species
            if not np.all(mmr == 0):
                raise ValueError(
                    f"cloud {species} has a default mass fraction different of 0, cannot perform test\n"
                    f"mass fraction was: {mmr}"
                )

    for species, mmr in test_parameters['mass_fractions_line_by_line'].items():
        if '(c)' in species or '(l)' in species or '(s)' in species or '(cr)' in species:  # condensed species
            if not np.all(mmr == 0):
                raise ValueError(
                    f"cloud {species} has a default mass fraction different of 0, cannot perform test\n"
                    f"mass fraction was: {mmr}"
                )


def check_cloud_complete_coverage_consistency(spectrum_function, benchmark, relative_tolerance,
                                              cloud_fraction, complete_coverage_clouds, mass_fractions,
                                              mass_fractions_clear=None,
                                              opaque_cloud_top_pressure=None, **kwargs):
    """Check if results obtained with partial cloud coverage are consistent."""
    if mass_fractions_clear is None:
        mass_fractions_clear = mass_fractions

    if opaque_cloud_top_pressure is not None:
        opaque_cloud_top_pressure_clear = None
    else:
        opaque_cloud_top_pressure_clear = opaque_cloud_top_pressure

    # Test flux cloudy
    print('Testing cloudy transit radii consistency...', end=' ')
    _, flux_cloudy, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        complete_coverage_clouds=None,
        **kwargs
    )

    _, flux_coverage1, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    assert np.allclose(
        flux_cloudy,
        flux_coverage1,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    # Test flux clear
    print('Testing clear transit radii consistency...', end=' ')
    _, flux_clear, _ = spectrum_function(
        mass_fractions=mass_fractions_clear,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure_clear,
        complete_coverage_clouds=None,
        **kwargs
    )

    _, flux_coverage0, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=0,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    assert np.allclose(
        flux_clear,
        flux_coverage0,
        atol=0,
        rtol=relative_tolerance
    )

    assert not np.allclose(  # check that there are differences between the cloudy and the cloudless cases
        flux_clear,
        flux_cloudy,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    benchmark.run(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=cloud_fraction,
        complete_coverage_clouds=complete_coverage_clouds,
        **kwargs
    )

    # Test flux with cloud fraction
    print('Testing transit radii with partial cloud coverage consistency...', end=' ')
    reference_file = benchmark._load_reference_file()

    assert np.allclose(
        test_parameters['cloud_parameters']['cloud_fraction'] * flux_cloudy
        + (1 - test_parameters['cloud_parameters']['cloud_fraction']) * flux_clear,
        reference_file.outputs['1'],
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')


def check_partial_cloud_coverage_full_consistency(spectrum_function, benchmark, relative_tolerance,
                                                  cloud_fraction, mass_fractions, mass_fractions_clear=None,
                                                  opaque_cloud_top_pressure=None, **kwargs):
    """Check if results obtained with partial cloud coverage are consistent."""
    if mass_fractions_clear is None:
        mass_fractions_clear = mass_fractions

    if opaque_cloud_top_pressure is not None:
        opaque_cloud_top_pressure_clear = None
    else:
        opaque_cloud_top_pressure_clear = opaque_cloud_top_pressure

    # Test flux cloudy
    print('Testing cloudy transit radii consistency...', end=' ')
    _, flux_cloudy, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        **kwargs
    )

    _, flux_coverage1, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=1,
        **kwargs
    )

    assert np.allclose(
        flux_cloudy,
        flux_coverage1,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    # Test flux clear
    print('Testing clear transit radii consistency...', end=' ')
    _, flux_clear, _ = spectrum_function(
        mass_fractions=mass_fractions_clear,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure_clear,
        **kwargs
    )

    _, flux_coverage0, _ = spectrum_function(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=0,
        **kwargs
    )

    assert np.allclose(
        flux_clear,
        flux_coverage0,
        atol=0,
        rtol=relative_tolerance
    )

    assert not np.allclose(  # check that there are differences between the cloudy and the cloudless cases
        flux_clear,
        flux_cloudy,
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

    benchmark.run(
        mass_fractions=mass_fractions,
        opaque_cloud_top_pressure=opaque_cloud_top_pressure,
        cloud_fraction=cloud_fraction,
        **kwargs
    )

    # Test flux with cloud fraction
    print('Testing transit radii with partial cloud coverage consistency...', end=' ')
    reference_file = benchmark._load_reference_file()

    assert np.allclose(
        test_parameters['cloud_parameters']['cloud_fraction'] * flux_cloudy
        + (1 - test_parameters['cloud_parameters']['cloud_fraction']) * flux_clear,
        reference_file.outputs['1'],
        atol=0,
        rtol=relative_tolerance
    )

    print('OK')

def get_cloud_parameters(mass_fraction_type, filling_species=None):
    mass_fractions = copy.deepcopy(test_parameters[mass_fraction_type])
    cloud_particles_mean_radii = {}
    cloud_f_sed = {}
    cloud_particle_radius_distribution_std = None
    cloud_b_hansen = {}

    for cloud, parameters in test_parameters['cloud_parameters']['cloud_species'].items():
        mass_fractions[cloud] = parameters['mass_fraction']
        cloud_particles_mean_radii[cloud] = parameters['radius']
        cloud_f_sed[cloud] = parameters['f_sed']
        cloud_b_hansen = parameters['b_hansen']

        if cloud_particle_radius_distribution_std is None:
            cloud_particle_radius_distribution_std = parameters['sigma_log_normal']

    if filling_species is not None:
        for species in filling_species:
            if species in mass_fractions:
                del mass_fractions[species]

    return (
        mass_fractions, cloud_particles_mean_radii, cloud_f_sed, cloud_particle_radius_distribution_std, cloud_b_hansen
    )

def get_main_model_parameters(spectral_model, **kwargs):
    """Calculate a SpectralModel spectrum and return the temperatures, mass fractions and mean molar masses in
    addition to wavelengths and spectra."""
    wavelengths, spectra = spectral_model.calculate_spectrum(**kwargs)

    return (wavelengths, spectra,
            spectral_model.temperatures, spectral_model.mass_fractions, spectral_model.mean_molar_masses)


# Initializations
def init_guillot_2010_temperature_profile():
    temperature_guillot = petitRADTRANS.physics.temperature_profile_function_guillot_global(
        pressures=test_parameters['pressures'],
        infrared_mean_opacity=test_parameters['temperature_guillot_2010_parameters']['infrared_mean_opacity'],
        gamma=test_parameters['temperature_guillot_2010_parameters']['gamma'],
        gravities=test_parameters['planetary_parameters']['reference_gravity'],
        intrinsic_temperature=test_parameters['temperature_guillot_2010_parameters']['intrinsic_temperature'],
        equilibrium_temperature=test_parameters['temperature_guillot_2010_parameters']['equilibrium_temperature']
    )

    return temperature_guillot


def init_radtrans_test():
    check_cloud_mass_fractions()

    tp_iso = test_parameters['temperature_isothermal'] * np.ones_like(test_parameters['pressures'])
    tp_guillot_2010 = init_guillot_2010_temperature_profile()

    return tp_iso, tp_guillot_2010

temperature_isothermal, temperature_guillot_2010 = init_radtrans_test()
